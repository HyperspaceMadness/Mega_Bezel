// Subsurface Lighting Model 
// https://www.shadertoy.com/view/dltGWl by Poisson

// top -> skin material with variable sss radius
// bottom -> leave material with variable sss radius

#define AA 3 // antialiasing

// ray sphere intersection function
// thanks to iq: https://iquilezles.org/articles/intersectors/
float sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {
    vec3 oc = ro - ce;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - ra*ra;
    float h = b*b - c;
    
    if(h<0.) return -1.;
    return -b - sqrt(h);
}

// intersection function
float intersect(vec3 ro, vec3 rd, float tmax, out vec3 on, out int oid) {
    float t = tmax;
    
    for (int i=0; i<10; i++) {
        vec3 ce = vec3((i%5)*2-4, i/5*2-1, 0); // sphere center
        float h = sphIntersect(ro, rd, ce, .95);
        if (h>0. && h<t) {
            on = normalize(ro-ce + rd*h); // normal
            oid = i;
            t = h;
        }
    }

    return t<tmax ? t : -1.;
}

// my subsurface scattering lighting model
// lambert + preintegrated sss + blinn ggx + shlick

// type -> type of diffusion model
// n -> normal
// l -> light direction
// rd -> ray direction
// kl -> light color
// kd -> diffuse color
// ks -> subsurface color
// ksr -> subsurface radius
// km -> roughness / microfacet amount
// kn -> refraction index
vec3 lighting(int type, vec3 n, vec3 l, vec3 rd, vec3 kl, vec3 kd, vec3 ks, vec3 ksr, float km, float kn) {
    float ndl = dot(n, l); // diffuse lambert / N⋅L
    float pndl = clamp( ndl, 0., 1.), // positive ndl
          nndl = clamp(-ndl, 0., 1.); // negative ndl
          
    // subsurface scattering
    vec3 sss;
    if (type==0) // exponential
        sss = .2 * pow(vec3(1.-pndl), 3./(ksr+.001)) * 
                   pow(vec3(1.-nndl), 3./(ksr+.001));
    else // gaussian         
        sss = .2 * exp(-3.*(nndl + pndl)/(ksr+.001));
   
    vec3 h = normalize(l - rd); // half vector
    float ndh = dot(n, h); // N⋅H
    
    // ggx / Trowbridge and Reitz specular model approximation
    float g = ndh*ndh * (km*km - 1.) + 1.;
    float ggx = km*km / (3.141592*g*g);

    // shlick approximation
    float fre = 1.+dot(rd, n); // fresnel
    // fresnel amount
    float f0 = (kn-1.)/(kn+1.);
          f0 = f0*f0;
    float kr = f0 + (1.-f0)*(1.-km)*(1.-km) * pow(fre, 5.); // reflectivity

    return kl*(pndl*(kd + kr*ggx) + kd*ks*ksr*sss); // diffuse + sss + specular
}

// rendering
vec3 render(vec3 ro, vec3 rd) {
    vec3 col = vec3(.5+.5*rd.y)*.025; // background
    
    vec3 n; int id;
    float t = intersect(ro, rd, 1e10, n, id);
    
    if (t>0.) {
        vec3 p = ro + rd*t; // hit point
                                
        vec3 difCol;
        vec3 sssCol;
        vec3 sssRad;
        float sssDif;
        float rou;
        float ior;
        int type;
                
        int row = id/5;
        if (row==1) { // skin material
            difCol = vec3(.6,.45,.25);
            sssCol = vec3(.75);
            sssRad = float(id%5)/3.*vec3(1,.25,.04);
            rou = .1;
            ior = 1.5;
            type = 1;
        } else { // leave material
            difCol = vec3(.5,.6,.2);
            sssCol = vec3(.6);
            sssRad = float(id%5)/3.*vec3(.6,1,.06);
            rou = .1;
            ior = 1.5;
            type = 1;
        }
                        
        col = lighting(type, n,          normalize(vec3(1,1,1)), rd,   vec3(1), difCol, sssCol, sssRad, rou, ior) + // key light
              lighting(type, n, normalize(vec3(-1,.4,.5)-.1*ro), rd, vec3(.25), difCol, sssCol, sssRad, rou, ior);  // rim light
    }
        
    return col;
}

// camera function
mat3 setCamera(vec3 ro, vec3 ta) {
    vec3 w = normalize(ta - ro); // forward vector
    vec3 u = normalize(cross(w, vec3(0,1,0))); // up vector
    vec3 v = cross(u, w); // side vector
    return mat3(u, v, w);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // normalized mouse coordinates
    vec2 mo = (iMouse.xy - .5*iResolution.xy)/iResolution.y;

    float an = .6*iTime + mo.x*3.141592; // camera xz rotation
    vec3 ro = 18.*vec3(sin(an),0,cos(an)); // ray origin
    vec3 ta = vec3(0); // target
    mat3 ca = setCamera(ro, ta); // camera matrix
    
    vec3 tot = vec3(0);
    for (int m=0; m<AA; m++)
    for (int n=0; n<AA; n++) {
        vec2 off = vec2(m,n) / float(AA) - .5; // AA offset
        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;
        
        vec3 rd = ca * normalize(vec3(p,3)); // ray direction
        vec3 col = render(ro, rd); // render
                
        col = 1.9*col/(.8+2.5*col); // tonemapping
        col = pow(col, vec3(.4545)); // gamma correction
        
        tot += col;
    }
    tot /= float(AA*AA);
    
    // vignette
    vec2 q = fragCoord/iResolution.xy;
    tot *= .3+.7*pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);

    // output
    fragColor = vec4(tot,1.0);
}
/*
    Mega Bezel - Creates a graphic treatment for the game play area to give a retro feel
    Copyright (C) 2019-2021 HyperspaceMadness - HyperspaceMadness@outlook.com

    Text code is from the Shadertoy "96-bit 8x12" Font by Flyguy

    See more at the libretro forum
    https://forums.libretro.com/t/hsm-mega-bezel-reflection-shader-feedback-and-updates

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#define DOWN_SCALE 2

#define MAX_INT_DIGITS 4

#define CHAR_SIZE vec2(8, 12)
#define CHAR_SPACING vec2(8, 12)

#define STRWIDTH(c) (c * CHAR_SPACING.x)
#define STRHEIGHT(c) (c * CHAR_SPACING.y)

#define NORMAL 0
#define INVERT 1
#define UNDERLINE 2

int TEXT_MODE = NORMAL;

/*
--------
-###----
##-##---
##-##---
-###----
#####-#-
##-####-
##--##--
##-###--
-###-##-
--------
--------

00000000
01110000
11011000
11011000
01110000
11111010
11011110
11001100
11011100
01110110
00000000
00000000

//Broken up into 4 8x3 (24 bit) chunks for each component of the vec4.
//Hexadecimal is being used to reduce clutter in the code but decimal still works.

00000000
01110000 -> 00000000 01110000 11011000 -> 0x0070D8
11011000

11011000
01110000 -> 11011000 01110000 11111010 -> 0xD870FA
11111010

11011110
11001100 -> 11011110 11001100 11011100 -> 0xDECCDC
11011100

01110110
00000000 -> 01110110 00000000 00000000 -> 0x760000
00000000

vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000)
*/

//Automatically generated from the 8x12 font sheet here:
//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm

vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);
vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);
vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);
vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);
vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);
vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);
vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);
vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);
vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);
vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);
vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);
vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);
vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);
vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);
vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);
vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);
vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);
vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);
vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);
vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);
vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);
vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);
vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);
vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);
vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);
vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);
vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);
vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);
vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);
vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);
vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);
vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);
vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);
vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);
vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);
vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);
vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);
vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);
vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);
vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);
vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);
vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);
vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);
vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);
vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);
vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);
vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);
vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);
vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);
vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);
vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);
vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);
vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);
vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);
vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);
vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);
vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);
vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);
vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);
vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);
vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);
vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);
vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);
vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);
vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);
vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);
vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);
vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);
vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);
vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);
vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);
vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);
vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);
vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);
vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);
vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);
vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);
vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);
vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);
vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);
vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);
vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);
vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);
vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);
vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);
vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);
vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);
vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);
vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);
vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);
vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);
vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);
vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);
vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);
vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);

vec2 textCanvasResolution = vec2(0);
vec2 printPos = vec2(0);

float epsilon = 0.001;

//Extracts bit b from the given number.
//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).
float extract_bit(float n, float b)
{
    b = clamp(b,-1.0,24.0);
	return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   
}

//Returns the pixel at uv in the given bit-packed sprite.
float sprite(vec4 spr, vec2 size, vec2 uv)
{
    uv = floor(uv);
    
    //Calculate the bit to extract (x + y * width) (flipped on x-axis)
    float bit = (size.x-uv.x-1.0) + uv.y * size.x;
    
    //Clipping bound to remove garbage outside the sprite's boundaries.
    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));
    
    float pixels = 0.0;
    pixels += extract_bit(spr.x, bit - 72.0);
    pixels += extract_bit(spr.y, bit - 48.0);
    pixels += extract_bit(spr.z, bit - 24.0);
    pixels += extract_bit(spr.w, bit - 00.0);
    
    return bounds ? pixels : 0.0;
}

//Prints a character and moves the print position forward by 1 character width.
float GetChar(vec4 ch, vec2 uv)
{
    if( TEXT_MODE == INVERT )
    {
      //Inverts all of the bits in the character.
      ch = pow(2.0,24.0)-1.0-ch;
    }
    if( TEXT_MODE == UNDERLINE )
    {
      //Makes the bottom 8 bits all 1.
      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,
      //then shifts it left 8 bits and adds 255 (binary 11111111).
      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  
    }

    float px = sprite(ch, CHAR_SIZE, uv - printPos);
    printPos.x += CHAR_SPACING.x;
    return px;
}


//Returns the digit sprite for the given number.
vec4 get_digit(float d)
{
    d = floor(d);
    
    if(d == 0.0) return ch_0;
    if(d == 1.0) return ch_1;
    if(d == 2.0) return ch_2;
    if(d == 3.0) return ch_3;
    if(d == 4.0) return ch_4;
    if(d == 5.0) return ch_5;
    if(d == 6.0) return ch_6;
    if(d == 7.0) return ch_7;
    if(d == 8.0) return ch_8;
    if(d == 9.0) return ch_9;
    return vec4(0.0);
}

//Prints out the given number starting at pos.
float print_number(float number, vec2 uv, float zeros)
{
    float result = 0.0;
    
	for(int i = 3;i >= -zeros;i--)
    {
        float digit = mod( number / pow(10.0, float(i)) , 10.0);
        
        if (i > -1 || fract(number) > epsilon)
        {
            if(i == -1 && fract(number) > epsilon) //Add a decimal point.
            {
                result += GetChar(ch_per, uv);
            }
            
            if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.
            {
                result += GetChar(get_digit(digit), uv);
            }
        }
    }   
    return result;
}

float print_integer(float number, int zeros, vec2 uv)
{
    float result = 0.0;

	for(int i = MAX_INT_DIGITS;i >= 0;i--)
    {
        float digit = mod( number / pow(10.0, float(i)) , 10.0);

        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.
        {
        	result += GetChar(get_digit(digit), uv);
        }
    }   
    return result;
}

float DrawResolutions(vec2 uv, vec2 viewport_size, vec2 screen_size, vec2 derezed_size, vec2 negative_crop_added_size, vec2 cropped_original_size, vec2 sampling_res, vec2 int_mult)
{
    float col = 0.0;
    
    float current_line_index = 0;
    float margin = STRHEIGHT(1);

    //Resolution Text
    printPos = vec2(margin, 0);
    
    TEXT_MODE = NORMAL;

    // Line 14 Viewport Resolution ----------------------------------------------------
    printPos.x = margin;
    printPos.y += STRHEIGHT(1);
    
    TEXT_MODE = NORMAL;  

    col += GetChar(ch_V, uv);
    col += GetChar(ch_i, uv);
    col += GetChar(ch_e, uv);
    col += GetChar(ch_w, uv);
    col += GetChar(ch_p, uv);
    col += GetChar(ch_o, uv);
    col += GetChar(ch_r, uv);
    col += GetChar(ch_t, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);

    col += GetChar(ch_spc, uv);
    col += print_integer(viewport_size.x,0, uv); 
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_x, uv);
    col += GetChar(ch_spc, uv);
    col += print_integer(viewport_size.y,0, uv); 


    // Line 13 Screen Resolution ----------------------------------------------------------
    printPos.x = margin;
    printPos.y += STRHEIGHT(1);

    col += GetChar(ch_S, uv);
    col += GetChar(ch_c, uv);
    col += GetChar(ch_r, uv);
    col += GetChar(ch_e, uv);
    col += GetChar(ch_e, uv);
    col += GetChar(ch_n, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);

    col += GetChar(ch_spc, uv);
    col += print_integer(screen_size.x,0, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_x, uv);
    col += GetChar(ch_spc, uv);
    col += print_integer(screen_size.y,0, uv);


    // Line 12 Final Aspect Ratio ----------------------------------------------------------
    printPos.x = margin;
    printPos.y += STRHEIGHT(1);
    
    col += GetChar(ch_F, uv);
    col += GetChar(ch_i, uv);
    col += GetChar(ch_n, uv);
    col += GetChar(ch_a, uv);
    col += GetChar(ch_l, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_A, uv);
    col += GetChar(ch_s, uv);
    col += GetChar(ch_p, uv);
    col += GetChar(ch_e, uv);
    col += GetChar(ch_c, uv);
    col += GetChar(ch_t, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    
    col += GetChar(ch_spc, uv);
    col += print_number(screen_size.x/screen_size.y > 1 ? screen_size.x/screen_size.y : screen_size.y/screen_size.x, uv, 2);


    // Line 11 Non-Int Scale Percent ----------------------------------------------------------
    printPos.x = margin;
    printPos.y += STRHEIGHT(1);
    
    col += GetChar(ch_N, uv);
    col += GetChar(ch_o, uv);
    col += GetChar(ch_n, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_I, uv);
    col += GetChar(ch_n, uv);
    col += GetChar(ch_t, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_S, uv);
    col += GetChar(ch_c, uv);
    col += GetChar(ch_l, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_pct, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    
    col += GetChar(ch_spc, uv);
    col += print_number(screen_size.y / viewport_size.y * 100, uv, 3);


    // Line 10 Int Scale Vertical ----------------------------------------------------------
    printPos.x = margin;
    printPos.y += STRHEIGHT(1);
    
    col += GetChar(ch_I, uv);
    col += GetChar(ch_n, uv);
    col += GetChar(ch_t, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_S, uv);
    col += GetChar(ch_c, uv);
    col += GetChar(ch_l, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_V, uv);
    col += GetChar(ch_e, uv);
    col += GetChar(ch_r, uv);
    col += GetChar(ch_t, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    
    col += GetChar(ch_spc, uv);
    col += print_number(int_mult.y, uv, 3);


    // Line 09 Int Scale Horizontal ----------------------------------------------------------
    printPos.x = margin;
    printPos.y += STRHEIGHT(1);
    
    col += GetChar(ch_I, uv);
    col += GetChar(ch_n, uv);
    col += GetChar(ch_t, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_S, uv);
    col += GetChar(ch_c, uv);
    col += GetChar(ch_l, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_H, uv);
    col += GetChar(ch_o, uv);
    col += GetChar(ch_r, uv);
    col += GetChar(ch_z, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    
    col += GetChar(ch_spc, uv);
    col += print_number(int_mult.x, uv, 3);


    // Line 08 Sampling Resolution ----------------------------------------------------------
    if (cropped_original_size.x != sampling_res.x || cropped_original_size.y != sampling_res.y)
    {
        printPos.x = margin;
        printPos.y += STRHEIGHT(1);
        
        col += GetChar(ch_S, uv);
        col += GetChar(ch_a, uv);
        col += GetChar(ch_m, uv);
        col += GetChar(ch_p, uv);
        col += GetChar(ch_l, uv);
        col += GetChar(ch_i, uv);
        col += GetChar(ch_n, uv);
        col += GetChar(ch_g, uv);
        col += GetChar(ch_spc, uv);
        col += GetChar(ch_R, uv);
        col += GetChar(ch_e, uv);
        col += GetChar(ch_s, uv);
        col += GetChar(ch_spc, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_dsh, uv);

        col += GetChar(ch_spc, uv);
        col += print_integer(sampling_res.x,0, uv);
        col += GetChar(ch_spc, uv);
        col += GetChar(ch_x, uv);
        col += GetChar(ch_spc, uv);
        col += print_integer(sampling_res.y,0, uv);
    }


    // Line 07 CROPPED Resolution ----------------------------------------------------------
    if (cropped_original_size.x != ROTATED_CORE_PREPPED_SIZE.x || cropped_original_size.y != ROTATED_CORE_PREPPED_SIZE.y)
    {
        printPos.x = margin;
        printPos.y += STRHEIGHT(1);
        
        col += GetChar(ch_C, uv);
        col += GetChar(ch_r, uv);
        col += GetChar(ch_o, uv);
        col += GetChar(ch_p, uv);
        col += GetChar(ch_p, uv);
        col += GetChar(ch_e, uv);
        col += GetChar(ch_d, uv);
        col += GetChar(ch_spc, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_dsh, uv);

        col += GetChar(ch_spc, uv);
        col += print_integer(cropped_original_size.x,0, uv);
        col += GetChar(ch_spc, uv);
        col += GetChar(ch_x, uv);
        col += GetChar(ch_spc, uv);
        col += print_integer(cropped_original_size.y,0, uv);
    }


    // Line 06 Negative Crop Resolution ----------------------------------------------------------
    if (derezed_size.x != ROTATED_CORE_PREPPED_SIZE.x || derezed_size.y != ROTATED_CORE_PREPPED_SIZE.y)
    {
        printPos.x = margin;
        printPos.y += STRHEIGHT(1);
        
        col += GetChar(ch_N, uv);
        col += GetChar(ch_e, uv);
        col += GetChar(ch_g, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_C, uv);
        col += GetChar(ch_r, uv);
        col += GetChar(ch_o, uv);
        col += GetChar(ch_p, uv);
        col += GetChar(ch_spc, uv);
        col += GetChar(ch_A, uv);
        col += GetChar(ch_d, uv);
        col += GetChar(ch_d, uv);
        col += GetChar(ch_spc, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_dsh, uv);

        col += GetChar(ch_spc, uv);
        col += print_integer(ROTATED_CORE_PREPPED_SIZE.x,0, uv);
        col += GetChar(ch_spc, uv);
        col += GetChar(ch_x, uv);
        col += GetChar(ch_spc, uv);
        col += print_integer(ROTATED_CORE_PREPPED_SIZE.y,0, uv);
    }


    // Line 05 DEREZ Resolution ----------------------------------------------------------
    if (derezed_size.x != ROTATED_CORE_ORIGINAL_SIZE.x || derezed_size.y != ROTATED_CORE_ORIGINAL_SIZE.y)
    {
        printPos.x = margin;
        printPos.y += STRHEIGHT(1);
        
        col += GetChar(ch_D, uv);
        col += GetChar(ch_e, uv);
        col += GetChar(ch_r, uv);
        col += GetChar(ch_e, uv);
        col += GetChar(ch_z, uv);
        col += GetChar(ch_e, uv);
        col += GetChar(ch_d, uv);
        col += GetChar(ch_spc, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_dsh, uv);
        col += GetChar(ch_dsh, uv);

        col += GetChar(ch_spc, uv);
        col += print_integer(derezed_size.x,0, uv);
        col += GetChar(ch_spc, uv);
        col += GetChar(ch_x, uv);
        col += GetChar(ch_spc, uv);
        col += print_integer(derezed_size.y,0, uv);
    }


    // Line 04 CORE Resolution ----------------------------------------------------------
    printPos.x = margin;
    printPos.y += STRHEIGHT(1);
    
    col += GetChar(ch_C, uv);
    col += GetChar(ch_o, uv);
    col += GetChar(ch_r, uv);
    col += GetChar(ch_e, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_dsh, uv);

    col += GetChar(ch_spc, uv);
    col += print_integer(ROTATED_CORE_ORIGINAL_SIZE.x,0, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_x, uv);
    col += GetChar(ch_spc, uv);
    col += print_integer(ROTATED_CORE_ORIGINAL_SIZE.y,0, uv);


    // Line 03 Preset Type ----------------------------------------------------------
    printPos.x = margin;
    printPos.y += STRHEIGHT(2);
    
#ifdef IS_ADV_PRESET
    col += GetChar(ch_A, uv);
    col += GetChar(ch_D, uv);
    col += GetChar(ch_V, uv);
    col += GetChar(ch_A, uv);
    col += GetChar(ch_N, uv);
    col += GetChar(ch_C, uv);
    col += GetChar(ch_E, uv);
    col += GetChar(ch_D, uv);
#endif

#ifdef IS_STD_PRESET
    col += GetChar(ch_S, uv);
    col += GetChar(ch_T, uv);
    col += GetChar(ch_A, uv);
    col += GetChar(ch_N, uv);
    col += GetChar(ch_D, uv);
    col += GetChar(ch_A, uv);
    col += GetChar(ch_R, uv);
    col += GetChar(ch_D, uv);
#endif

#ifdef IS_GLASS_PRESET
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_G, uv);
    col += GetChar(ch_L, uv);
    col += GetChar(ch_A, uv);
    col += GetChar(ch_S, uv);
    col += GetChar(ch_S, uv);
#endif

#ifdef IS_NO_REFLECT_PRESET
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_N, uv);
    col += GetChar(ch_O, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_R, uv);
    col += GetChar(ch_E, uv);
    col += GetChar(ch_F, uv);
    col += GetChar(ch_L, uv);
    col += GetChar(ch_E, uv);
    col += GetChar(ch_C, uv);
    col += GetChar(ch_T, uv);
#endif

#ifdef IS_POTATO_PRESET
    col += GetChar(ch_P, uv);
    col += GetChar(ch_0, uv);
    col += GetChar(ch_T, uv);
    col += GetChar(ch_A, uv);
    col += GetChar(ch_T, uv);
    col += GetChar(ch_O, uv);
#endif


    // Line 02 Version ----------------------------------------------------------
    printPos.x = margin;
    printPos.y += STRHEIGHT(1);

    col += GetChar(ch_0, uv);
    col += GetChar(ch_per, uv);
    col += GetChar(ch_9, uv);
    col += GetChar(ch_per, uv);
    col += GetChar(ch_1, uv);
    col += GetChar(ch_0, uv);
    col += GetChar(ch_7, uv);
    col += GetChar(ch_spc, uv);

    // Date
    col += GetChar(ch_2, uv);
    col += GetChar(ch_0, uv);
    col += GetChar(ch_2, uv);
    col += GetChar(ch_2, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_0, uv);
    col += GetChar(ch_4, uv);
    col += GetChar(ch_dsh, uv);
    col += GetChar(ch_0, uv);
    col += GetChar(ch_2, uv);

    // Revision
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_R, uv);
    col += GetChar(ch_e, uv);
    col += GetChar(ch_v, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_1, uv);


    // Line 01 Title ----------------------------------------------------------
    printPos.x = margin;
    printPos.y += STRHEIGHT(1);

    col += GetChar(ch_M, uv);
    col += GetChar(ch_E, uv);
    col += GetChar(ch_G, uv);
    col += GetChar(ch_A, uv);
    col += GetChar(ch_spc, uv);
    col += GetChar(ch_B, uv);
    col += GetChar(ch_E, uv);
    col += GetChar(ch_Z, uv);
    col += GetChar(ch_E, uv);
    col += GetChar(ch_L, uv);
    col += GetChar(ch_spc, uv);


    TEXT_MODE = NORMAL;  

    return col;
}

// Returns a 
float GetTextMask(vec2 in_coord, vec2 viewport_size, vec2 screen_size, vec2 derezed_size, vec2 negative_crop_added_size, vec2 cropped_original_size, vec2 sampling_res, vec2 int_mult, vec2 canvas_size)
{
    in_coord = (in_coord - 0.5) * vec2(1, -1) + 0.5;
    float downscale = 1;
    if (canvas_size.y > 600) downscale = 2;
    if (canvas_size.y > 1000) downscale = 3;

	textCanvasResolution = global.OutputSize.xy / downscale;
    vec2 uv = global.OutputSize.xy * in_coord;
	vec2 downscaled_uv = floor(global.OutputSize.xy * in_coord / downscale);
    
	float pixel = DrawResolutions(downscaled_uv, viewport_size, screen_size, derezed_size, negative_crop_added_size, cropped_original_size, sampling_res, int_mult);
    
    vec3 col = vec3(1);
    pixel *= (1 - distance(mod(uv, vec2(1.0)), vec2(0.65))) * 1.2;
    col *= mix(vec3(0), vec3(1, 1, 1), pixel);

	return col.r;
}